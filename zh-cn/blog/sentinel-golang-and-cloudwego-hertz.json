{
  "filename": "sentinel-golang-and-cloudwego-hertz.md",
  "__html": "<h1>Hertz 和 Sentinel Go 的对接方案</h1>\n<h2>介绍</h2>\n<p>在以云原生为技术支撑的背景下，各个公司都开源了自己的微服务框架或产品，如耳熟能详的 Istio、Envoy、Kratos、Go-zero 等。前段时间字节跳动也开源了 <strong><a href=\"https://mp.weixin.qq.com/s/D1Pol8L9F_5-Yte_k4DH8A\">超大规模的企业级微服务 HTTP 框架 — Hertz</a></strong>。</p>\n<p>经过了字节跳动内部一年多的使用和迭代，高性能企业级 HTTP 框架—— Hertz，已在 <a href=\"https://github.com/cloudwego\">CloudWeGo</a> 正式开源啦！Hertz 已经成为了字节跳动内部最大的 HTTP 框架，线上接入的服务数量超过<strong>1 万</strong>，峰值 QPS 超过 <strong>4 千万</strong>，具有<strong>高易用性</strong>、<strong>易扩展</strong>、<strong>低时延</strong>的特点。对于字节跳动服务框架团队和 CloudWeGo 而言，Hertz 将不仅仅是一个开源项目，它也是一个真实的超大规模企业级实践。</p>\n<h2>背景</h2>\n<p>鉴于 Hertz 自身没有熔断限流的能力，于是将 <a href=\"https://github.com/alibaba/sentinel-golang\">Sentinel Go</a> 这种成熟的方案通过中间件的方式引入进来进行流量的熔断和处理。</p>\n<p>此方案将介绍如何使 Hertz 可以以中间件的形式引入 sentinel-golang。</p>\n<h2>Sentinel 中 adapter 的实现思路</h2>\n<h3>提供自定义处理函数</h3>\n<p>adapter 提供了 <code>WithResourceExtractor</code> 添加自定义资源函数 和 <code>WithBlockFallback</code> 自定义失败回调函数等 Option 来对程序进行个性化处理</p>\n<blockquote>\n<p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p>\n<ul>\n<li>\n<p>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</p>\n</li>\n<li>\n<p>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制\n热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>WithResourceExtractor</code></td>\n<td><code>WithResourceExtractor</code> 为设置网络请求的自定义函数，通过自定义的资源名和 Sentinel-golang 中的 热点参数流控规则 的 <code>Resource</code> 相匹配以达到自定义规则的目的</td>\n</tr>\n<tr>\n<td><code>WithBlockFallback</code></td>\n<td><code>WithBlockFallback</code> 为设置请求被阻断时的自定义回调函数，可以通过 <code>context.Context</code> 和 <code>app.RequestContext</code> 分别来进行错误日志打印和自定义回调处理</td>\n</tr>\n</tbody>\n</table>\n<h3>如何使用提供的自定义函数</h3>\n<p>以下为使用 <code>WithResourceExtracto</code>r 时的伪代码</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// eg：FullPath 为 /ping</span>\nh.use(SentinelMiddleware(\n    WithResourceExtractor(\n       <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(c context.Context, ctx *app.RequestContext)</span> <span class=\"hljs-title\">string</span></span> {\n          <span class=\"hljs-keyword\">return</span> ctx.FullPath()\n       },\n    ),\n))\n\n<span class=\"hljs-comment\">// 默认的 resourceName eg: GET:/ping</span>\nresourceName := <span class=\"hljs-keyword\">string</span>(c.Request.Method()) + <span class=\"hljs-string\">\":\"</span> + c.FullPath()\n\n<span class=\"hljs-comment\">// 通过 WithResourceExtractor 使用自定义的 resourceName </span>\n<span class=\"hljs-keyword\">if</span> options.resourceExtract != <span class=\"hljs-literal\">nil</span> {\n   <span class=\"hljs-comment\">// 为上方定义的 /ping </span>\n   resourceName = options.resourceExtract(ctx, c)\n}\n\n<span class=\"hljs-comment\">// 将 resourceName 放入 sentinel.Entry</span>\nentry, err := sentinel.Entry(\n   resourceName,\n   sentinel.WithResourceType(base.ResTypeWeb),\n   sentinel.WithTrafficType(base.Inbound),\n)\n</code></pre>\n<p>以下为使用 <code>WithBlockFallback</code> 时进行自定义错误返回的伪代码</p>\n<pre><code class=\"language-Go\"><span class=\"hljs-comment\">// 在 block 时 返回自定义的 json 数据</span>\nh.use(SentinelMiddleware(\n    WithBlockFallback(<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(c context.Context, ctx *app.RequestContext)</span></span> {\n       ctx.AbortWithStatusJSON(<span class=\"hljs-number\">400</span>, <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">interface</span>{}{\n          <span class=\"hljs-string\">\"code\"</span>:    <span class=\"hljs-number\">400</span>,\n          <span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"busy\"</span>,\n       })\n    ),\n)\n\n<span class=\"hljs-keyword\">if</span> options.blockFallback != <span class=\"hljs-literal\">nil</span> {\n   <span class=\"hljs-comment\">// 通过 WithResourceExtractor 使用自定义的 json 返回</span>\n   options.blockFallback(ctx, c)\n} <span class=\"hljs-keyword\">else</span> {\n   <span class=\"hljs-comment\">// 默认返回 http.StatusTooManyRequests: 403</span>\n   c.AbortWithStatus(http.StatusTooManyRequests)\n}\n</code></pre>\n<h3>Hertz Server 中间件的业务实现</h3>\n<h4>自定义函数的注入原理</h4>\n<p><code>evaluateServerOptions</code> 为 server middleware 的 option 注入函数，它内部将存放默认的实现逻辑，用户可以通过自定义 option 的方式将默认实现替换为自定义逻辑</p>\n<pre><code class=\"language-Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">evaluateServerOptions</span><span class=\"hljs-params\">(opts []ServerOption)</span> *<span class=\"hljs-title\">serverOptions</span></span> {\n   <span class=\"hljs-comment\">// 提供默认实现 </span>\n   options := &amp;serverOptions{\n      resourceExtract: <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(c context.Context, ctx *app.RequestContext)</span> <span class=\"hljs-title\">string</span></span> {\n         <span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"%v:%v\"</span>, <span class=\"hljs-keyword\">string</span>(ctx.Request.Method()), ctx.FullPath())\n      },\n      blockFallback: <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(c context.Context, ctx *app.RequestContext)</span></span> {\n         ctx.AbortWithStatus(http.StatusTooManyRequests)\n      },\n   }\n   <span class=\"hljs-comment\">// 将用户的自定义 option 同默认配置进行替换</span>\n   options.Apply(opts)\n   <span class=\"hljs-keyword\">return</span> options\n}\n</code></pre>\n<h4>Server Middleware 的实现逻辑</h4>\n<blockquote>\n<p>使用 Sentinel 的 Entry API 将业务逻辑封装起来，这一步称为“埋点”。每个埋点都有一个资源名称（resource），代表触发了这个资源的调用或访问。</p>\n</blockquote>\n<p>以下为大致的伪代码：</p>\n<pre><code class=\"language-Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">SentinelServerMiddleware</span><span class=\"hljs-params\">(opts ...Option)</span> <span class=\"hljs-title\">app</span>.<span class=\"hljs-title\">HandlerFunc</span></span> {\n   options := evaluateOptions(opts)\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, c *app.RequestContext)</span></span> {\n      <span class=\"hljs-comment\">// 获取默认的 resourceName 或自定义的资源名</span>\n     resourceName := options.resourceExtract(c, ctx)\n   \n      <span class=\"hljs-comment\">// 进行埋点</span>\n      entry, err := sentinel.Entry(\n         resourceName,\n         sentinel.WithResourceType(base.ResTypeWeb),\n         sentinel.WithTrafficType(base.Inbound),\n      )\n      <span class=\"hljs-comment\">// 产生 err 就应该停止继续业务逻辑</span>\n      <span class=\"hljs-comment\">// 使用默认的响应逻辑或自定义的响应逻辑</span>\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n       options.blockFallback(c, ctx)\n       <span class=\"hljs-keyword\">return</span>\n    }\n      <span class=\"hljs-keyword\">defer</span> entry.Exit()\n      c.Next(ctx)\n   }\n}\n</code></pre>\n<p>请求进入中间件的逻辑流程图：</p>\n<p><img src=\"./img/sentinel-golang-hertz1.jpg\" alt=\"\"></p>\n<h2>Hertz adapter 和 Sentinel Gin adpter 的差异</h2>\n<ul>\n<li>\n<p>Hertz 提供客户端和服务端的功能，和 gin 并不一样，gin 只提供服务端功能</p>\n</li>\n<li>\n<p>Hertz server 和 client 的 middleware 原理实现并不相同，Hertz server 使用 <code>app.HandlerFunc</code> Hertz middleware 使用 <code>middleware.Endpoint</code> ，所以需要分别编写</p>\n</li>\n<li>\n<p>将中间件处理函数 <code>gin.HandlerFunc</code> 置换为 Hertz 的 <code>app.HandlerFunc</code></p>\n</li>\n<li>\n<p>将option的基本类型从gin 的 <code>HandlerFunc</code>替换Hertz 的 <code>HandlerFunc</code> 对请求进行自定义处理</p>\n</li>\n</ul>\n<pre><code class=\"language-Go\"><span class=\"hljs-comment\">// gin 的 HandlerFunc</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(*gin.Context)</span>\n// <span class=\"hljs-title\">hertz</span> 的 <span class=\"hljs-title\">HandlerFunc</span>\n<span class=\"hljs-title\">func</span><span class=\"hljs-params\">(ctx context.Context, c *app.RequestContext)</span>\n</span></code></pre>\n<h2>Sentinel Hertz client adapter 实现</h2>\n<ol>\n<li>中间件函数使用 hertz client middleware 的 <code>middleware.Endpoint</code></li>\n<li>由于 client middleware 必须保持<strong>默认</strong>格式，所以使用构造函数从外部给 middlware 函数内部 的options 进行赋值，最后返回一个统一格式的中间件</li>\n</ol>\n<h3>自定义函数的注入原理</h3>\n<p><code>evaluateClientOptions</code> 为 client middleware 的 option 注入函数，它内部将存放默认的实现逻辑，用户可以通过自定义 option 的方式将默认实现替换为自定义逻辑</p>\n<p>以下为 <code>evaluateClientOptions</code> 的实现伪代码</p>\n<pre><code class=\"language-Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">evaluateClientOptions</span><span class=\"hljs-params\">(opts []ClientOption)</span> *<span class=\"hljs-title\">clientOptions</span></span> {\n    <span class=\"hljs-comment\">// 提供默认实现 </span>\n   options := &amp;clientOptions{\n      resourceExtractForClient: <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, req *protocol.Request, resp *protocol.Response)</span> <span class=\"hljs-title\">string</span></span> {\n         <span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"%v:%v\"</span>, <span class=\"hljs-keyword\">string</span>(req.Method()), <span class=\"hljs-keyword\">string</span>(req.Path()))\n      },\n      blockFallbackForClient: <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, req *protocol.Request, resp *protocol.Response)</span></span> {\n         resp.SetStatusCode(http.StatusTooManyRequests)\n      },\n   }\n   <span class=\"hljs-comment\">// 将用户的自定义 option 同默认配置进行替换</span>\n   options.Apply(opts)\n   <span class=\"hljs-keyword\">return</span> options\n}\n</code></pre>\n<p>以下为伪代码：</p>\n<pre><code class=\"language-Go\"><span class=\"hljs-comment\">// 中间件默认格式</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(next client.Endpoint)</span> <span class=\"hljs-title\">client</span>.<span class=\"hljs-title\">Endpoint</span></span> {\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, req *protocol.Request, resp *protocol.Response)</span> <span class=\"hljs-params\">(err error)</span></span> {\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span> \n   }\n}\n\n<span class=\"hljs-comment\">// 构造函数的初步实现方案</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">SentinelClientMiddleware</span><span class=\"hljs-params\">(opts ...Option)</span> <span class=\"hljs-title\">client</span>.<span class=\"hljs-title\">Endpoint</span></span> {\n   <span class=\"hljs-comment\">// 注入 option</span>\n   options := evaluateClientOptions(opts)\n   <span class=\"hljs-comment\">// 进行中间件实现</span>\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(next client.Endpoint)</span> <span class=\"hljs-title\">client</span>.<span class=\"hljs-title\">Endpoint</span></span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, req *protocol.Request, resp *protocol.Response)</span> <span class=\"hljs-params\">(err error)</span></span> {\n         <span class=\"hljs-comment\">// 进行option注入以及进行埋点处理等</span>\n         ...\n         err = next(ctx, req, resp)\n         <span class=\"hljs-comment\">// 处理错误</span>\n         <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n            <span class=\"hljs-keyword\">return</span> err\n         }\n         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n      }\n   }\n}\n</code></pre>\n<ul>\n<li>Client middleware 逻辑使用伪代码展示</li>\n</ul>\n<pre><code class=\"language-Go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">SentinelClientMiddleware</span><span class=\"hljs-params\">(opts ...ClientOption)</span> <span class=\"hljs-title\">client</span>.<span class=\"hljs-title\">Middleware</span></span> {\n   <span class=\"hljs-comment\">// 注入默认实现或用户的自定义实现</span>\n   options := evaluateClientOptions(opts)\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(next client.Endpoint)</span> <span class=\"hljs-title\">client</span>.<span class=\"hljs-title\">Endpoint</span></span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(ctx context.Context, req *protocol.Request, resp *protocol.Response)</span> <span class=\"hljs-params\">(err error)</span></span> {\n         <span class=\"hljs-comment\">// 使用默认ResourceName: eg: GET:/ping 或自定义资源名</span>\n         resourceName := options.resourceExtractForClient(ctx, req, resp)\n          <span class=\"hljs-comment\">// 进行埋点</span>\n         entry, blockErr := sentinel.Entry(\n            resourceName,\n            sentinel.WithResourceType(base.ResTypeWeb),\n            sentinel.WithTrafficType(base.Outbound),\n         )\n         <span class=\"hljs-comment\">// 发生熔断，应停止继续</span>\n         <span class=\"hljs-keyword\">if</span> blockErr != <span class=\"hljs-literal\">nil</span> {\n            <span class=\"hljs-comment\">// 使用默认响应或用户自定义响应</span>\n            options.blockFallbackForClient(ctx, req, resp)\n            <span class=\"hljs-keyword\">return</span>\n         }\n         <span class=\"hljs-keyword\">defer</span> entry.Exit()\n         err = next(ctx, req, resp)\n         <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n            sentinel.traceError(entry, err)\n            <span class=\"hljs-keyword\">return</span> err\n         }\n         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n      }\n   }\n}\n</code></pre>\n<p>Client 的基本业务流程图：</p>\n<p><img src=\"./img/sentinel-golang-hertz2.jpg\" alt=\"\"></p>\n"
}